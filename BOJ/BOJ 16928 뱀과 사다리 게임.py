def bfs():
    v = [0] * 101  # 방문 확인 리스트: 보드를 1번부터 사용하므로, 인덱스 0을 사용하지 않는 대신 리스트를 한 칸 늘림
    q = [0] * 101  # 보드 수 + 1 만큼의 공간을 가진 큐를 초기화
    q[0] = 1  # 보드의 처음에 출발지인 1을 입력
    ptr = 1  # 다음 값을 입력할 곳을 가리키는 포인터 선언
    for n in q:  # 큐를 순회하며
        for i in range(1, 7):  # 주사위의 각 눈금(1 ~ 6)에 따라
            cn = n + i  # 보드의 도착지로 이동
            if 0 < cn <= 100 and not v[cn]:  # 도착지가 보드에 존재하고 이전에 방문한 적이 없다면,
                v[cn] = v[n] + 1  # 도착지까지 굴린 주사위의 횟수를 방문 확인 리스트에 기록.
                if not v[adl[cn]]: v[adl[cn]] = v[n] + 1  # 사다리나 뱀이 있으며 그 도착지에 방문한 적이 없다면 마찬가지로 같은 주사위 횟수를 기록
                q[ptr] = adl[cn]  # 큐에 뱀이나 사다리 등을 모두 고려한 최종 도착지를 enqueue
                ptr += 1  # 큐의 다음 칸을 가리킴
            if v[100]:
                return v[100]  # 100번 보드의 방문이 확인됐다면 그 주사위 횟수를 반환


N, M = map(int, input().split())
# 인접 리스트: 보드를 1번부터 사용하므로, 인덱스 0을 사용하지 않는 대신 리스트를 한 칸 늘림
adl = [i for i in range(101)]

for _ in range(N + M):  # 반복문을 통해, 출발지에 뱀과 사다리가 있다면 인접 리스트에 저장된 도착지를 갱신함
    x, y = map(int, input().split())
    adl[x] = y

print(bfs())  # 100번 보드까지 필요한 주사위의 횟수를 출력
